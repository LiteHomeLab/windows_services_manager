---

# 项目名称：WinServiceManager (基于 WinSW)

## 1. 项目概述
开发一个基于 Windows Presentation Foundation (WPF) 的桌面应用程序，旨在简化将任意可执行文件（exe）或脚本（Python, Bat, Node.js 等）注册为 Windows 本地系统服务的过程。
**核心架构策略：** 采用 **WinSW (Windows Service Wrapper)** 作为底层服务宿主容器，上层 UI 负责配置文件的生成、服务注册命令的调度以及运行状态的监控。

## 2. 技术栈与依赖
*   **开发语言:** C# / .NET 8 (或 .NET 6)
*   **UI 框架:** WPF (使用 MVVM 模式，推荐 CommunityToolkit.Mvvm)
*   **核心依赖库:**
    *   `System.ServiceProcess.ServiceController` (用于获取服务状态和控制启停)
    *   `WinSW v3.0+` (外部二进制文件，作为 Resource 或存放在 templates 目录)
*   **权限要求:** 应用程序必须以 **Administrator (管理员)** 权限运行，需在 `app.manifest` 中配置 `<requestedExecutionLevel level="requireAdministrator" ... />`。

## 3. 架构设计

### 3.1 目录结构规范
应用程序采取 **“每服务一目录”** 的隔离策略，确保配置互不干扰。

```text
/AppRoot
  |-- WinServiceManager.exe       // 主程序
  |-- templates/
      |-- WinSW-x64.exe           // WinSW 母本文件（需预先下载放入）
  |-- services/                   // 所有已创建服务的存储根目录
      |-- {Service_Unique_ID}/    // 单个服务的沙盒目录
          |-- runner.exe          // (复制并重命名的 WinSW.exe)
          |-- runner.xml          // (该服务的 WinSW 配置文件)
          |-- logs/               // (WinSW 自动生成的日志目录)
              |-- runner.out.log  // 标准输出
              |-- runner.err.log  // 错误输出
```

### 3.2 数据模型 (ServiceMetaInfo)
虽然 WinSW 使用 XML 配置，但主程序应维护一份 JSON 或 LiteDB 数据库来记录元数据，便于 UI 列表展示。

```csharp
public class ServiceItem
{
    public string Id { get; set; }           // GUID，用作目录名和 ServiceID
    public string DisplayName { get; set; }  // UI显示名称，如 "My Python Script"
    public string ExecutablePath { get; set; } // e.g., "C:\Python39\python.exe"
    public string ScriptPath { get; set; }   // e.g., "D:\Projects\main.py" (如果是脚本)
    public string Arguments { get; set; }    // 启动参数
    public string WorkingDirectory { get; set; }
    public ServiceStatus Status { get; set; } // Running, Stopped, NotInstalled
}
```

## 4. 详细功能实现逻辑

### 4.1 功能模块一：创建与注册服务 (Service Factory)
**输入：** 用户填写服务名、选择 Python/Exe 路径、参数。
**执行步骤：**
1.  **生成 ID:** 生成一个新的 GUID（例如 `MyCustomService_123`）。
2.  **创建目录:** 在 `./services/{GUID}/` 创建文件夹。
3.  **复制宿主:** 将 `templates/WinSW-x64.exe` 复制到该目录，并重命名为 `MyCustomService_123.exe` (这点很重要，exe 名字决定了服务 ID)。
4.  **生成配置:** 在同目录下创建 `MyCustomService_123.xml`。
    *   *AI 指令:* 请生成如下 XML 内容：
    ```xml
    <service>
      <id>MyCustomService_123</id>
      <name>My Custom Service (Display Name)</name>
      <description>Managed by WinServiceManager</description>
      <executable>C:\Python39\python.exe</executable>
      <arguments>d:\scripts\main.py --prod</arguments>
      <workingdirectory>d:\scripts\</workingdirectory>
      <log mode="roll-by-size">
        <sizeThreshold>10240</sizeThreshold>
        <keepFiles>8</keepFiles>
      </log>
      <!-- 关键：配置优雅停止策略 -->
      <stopparentprocessfirst>true</stopparentprocessfirst>
    </service>
    ```
5.  **执行安装:** 使用 `System.Diagnostics.Process` 调用命令行：
    *   `MyCustomService_123.exe install`
6.  **自动启动:** 若安装成功，执行 `MyCustomService_123.exe start`。

### 4.2 功能模块二：服务控制 (Service Controller)
**输入：** `ServiceId` (即系统服务名)。
**实现逻辑：**
*   **状态检查:** 轮询 `ServiceController(serviceName).Status`。
*   **启动:** 调用 `ServiceController.Start()`。
*   **停止:** 调用 `ServiceController.Stop()`。
*   **卸载:**
    1.  停止服务。
    2.  调用命令行 `MyCustomService_123.exe uninstall`。
    3.  删除对应的 `./services/{GUID}/` 目录。

### 4.3 功能模块三：日志查看 (Log Viewer)
**实现逻辑：**
*   定位到 `./services/{GUID}/logs/` 目录。
*   找到最新的 `.out.log` 或 `.err.log` 文件。
*   **关键技术点:** 读取文件时必须使用 `FileShare.ReadWrite` 模式，因为 WinSW 正在写入该文件，普通读取会报错“文件被占用”。
    ```csharp
    using (var stream = File.Open(logPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
    using (var reader = new StreamReader(stream))
    {
        // 读取内容并显示在 UI 的 TextBox 中
    }
    ```

## 5. UI/UX 建议
1.  **主界面:** 左侧一个 `ListView` 展示服务列表（带状态指示灯：红/绿），右侧是详情页和控制按钮（启动、停止、卸载、查看日志）。
2.  **新增对话框:** 必须包含“选择工作目录”的选项，自动默认填入脚本所在的父目录。
3.  **日志窗口:** 建议使用 `TextArea` 并支持“自动滚动到底部”。

## 6. 验收标准 (Acceptance Criteria)
1.  **环境隔离验证：** 程序重启后，列表能重新加载已注册的服务。
2.  **生命周期验证：** 可以在 UI 上注册一个 Python 脚本（无限循环打印日志），点击开始后，在 Windows 自带的 `services.msc` 中能看到该服务且为“正在运行”状态。
3.  **持久化验证：** 重启 Windows 系统后，该服务自动启动运行。
4.  **停止逻辑验证：** 点击 UI 上的停止，Python 进程被杀掉，无残留。
5.  **异常处理：** 如果脚本路径不存在，服务启动失败，UI 应显示“Stopped”并允许用户查看 `err.log` 里的错误信息。

